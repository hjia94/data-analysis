# -*- coding: utf-8 -*-
"""
Sheffield implementation of Thomson scattering form factor calculation
Based on Sheffield, Plasma Scattering of Electromagnetic Radiation 2nd ed.

Original code from Sheffield Appendix 4 matlab code
Quote:
    In this section we apply the methods discussed above to calculate a scattering
    spectrum using MATLAB routines. The main script sets the plasma parameters,
    experimental geometry, and probe laser specifications. An ascii table of
    the derivative of the plasma dispersion function dW(xi)/dxi as a function of
    xi = w / (k*vthi )/sqrt(pi) must be generated by running the script wtable.m below. This
    table is used by the Zprime.m function which is called from the main script.

Author: Jia Han
Date: 2025-03-19
"""

import numpy as np
from scipy.interpolate import interp1d
import matplotlib.pyplot as plt
import os

r_0 = 2.8179403262e-13  # classical electron radius in cm

class SheffieldThomson:
    """
    Class for Thomson scattering calculations using Sheffield's approach.
    
    This class encapsulates all functionality needed to compute the spectral density
    function S(k,w) for Thomson scattering and calculate related quantities.
    
    Attributes:
    -----------
    probe_wavelength : float
        Probe wavelength in nm
    T_e : float
        Electron temperature in eV
    T_i : float
        Ion temperature in eV
    n_e : float
        Electron density in cm^-3
    scattering_angle : float
        Scattering angle in degrees
    ions : str or tuple
        Ion species information, either as a string (e.g., "He+") or
        as a tuple of (Z, A, fract) arrays
    """
    
    def __init__(self, probe_wavelength, T_e, T_i, n_e, scattering_angle=180, ions="He+"):
        """
        Initialize the Thomson scattering calculator.
        
        Parameters:
        -----------
        probe_wavelength : float
            Probe wavelength in nm
        T_e : float
            Electron temperature in eV
        T_i : float
            Ion temperature in eV
        n_e : float
            Electron density in cm^-3
        scattering_angle : float, optional
            Scattering angle in degrees (default: 180)
        ions : str or tuple, optional
            Ion species information (default: "He+")
        """
        # Store input parameters
        self.probe_wavelength = probe_wavelength
        self.T_e = T_e
        self.T_i = T_i
        self.n_e = n_e
        self.scattering_angle = scattering_angle
        
        # Parse ion information
        self._parse_ions(ions)
        
        # Calculated parameters
        self.c_speed = 299792458  # Speed of light in m/s
        self.probe_freq = self.c_speed / (self.probe_wavelength * 1e-9)  # Hz
        self.omega_in = 2 * np.pi * self.probe_freq  # rad/s
        
        # Scattering parameter
        self.lambda_i_cm = self.probe_wavelength * 1e-7  # nm to cm
        self.alpha = self.compute_alpha(self.lambda_i_cm, self.scattering_angle, self.n_e, self.T_e)
        
        # Initialize frequency arrays and spectral density
        self.omega_arr = None
        self.Skw = None
    
    def _parse_ions(self, ions):
        """
        Parse ion information and set ion parameters.
        
        Parameters:
        -----------
        ions : str or tuple
            Ion species information
        """
        if isinstance(ions, str):
            if ions == "He+":
                self.Z = np.array([1])
                self.A = np.array([4])
            elif ions == "H+":
                self.Z = np.array([1])
                self.A = np.array([1])
            else:
                # Default to He+ if ion type not recognized
                self.Z = np.array([1])
                self.A = np.array([4])
            self.fract = np.array([1])
        elif isinstance(ions, tuple) and len(ions) == 3:
            self.Z, self.A, self.fract = ions
        else:
            raise ValueError("ions must be a string or a tuple of (Z, A, fract)")
    
    def compute_alpha(self, lambda_i, theta, n_e, T_e):
        """
        Compute alpha based on the given equation.

        Parameters:
        lambda_i (float): Wavelength in cm
        theta (float): Scattering angle in degrees
        n_e (float): Electron density in cm^-3
        T_e (float): Electron temperature in eV

        Returns:
        float: Value of alpha
        """
        theta_rad = np.radians(theta)  # Convert degrees to radians
        alpha = (1.08e-4 * lambda_i / np.sin(theta_rad / 2)) * np.sqrt(n_e / T_e)
        return alpha
    
    def compute_theta(self, lambda_i, alpha, n_e, T_e):
        """
        Rearrange the alpha equation to solve for theta

        Parameters:
        lambda_i (float): Wavelength in cm
        alpha (float): Scattering parameter
        n_e (float): Electron density in cm^-3
        T_e (float): Electron temperature in eV

        Returns:
        float: Scattering angle in degrees
        """
        # Solve for sin(theta_rad / 2)
        sin_half_theta = (1.08e-4 * lambda_i * np.sqrt(n_e / T_e)) / alpha
        
        # Calculate theta_rad
        theta_rad = 2 * np.arcsin(sin_half_theta)
        
        # Convert radians to degrees
        theta_deg = np.degrees(theta_rad)
        
        return theta_deg
    
    def _generate_dispersion_derivative_table(self, ximin=-10, ximax=10, dx=0.01, N=4):
        """
        Generate the derivative tables for the plasma dispersion function.
        
        Parameters:
        -----------
        ximin : float, optional
            Minimum xi value (default: -10)
        ximax : float, optional
            Maximum xi value (default: 10)
        dx : float, optional
            Step size (default: 0.01)
        N : int, optional
            Integration subdivision factor (default: 4)
        """
        print("Generating plasma dispersion derivative tables...", end='')

        xi = np.arange(ximin, ximax + dx, dx)
        L = len(xi)
        IPV = np.zeros(L, dtype='float64')
        RP = np.zeros(L, dtype='float64')

        for i in range(L):
            phi = 0.01 * abs(xi[i]) + 1e-6    # defining how close to get to singularity
            dz = phi / N                      # integration step size is N times smaller than phi

            zm = np.arange(xi[i] - phi, ximin - 1, -dz)   # define arrays symmetrically around xi
            zp = np.arange(xi[i] + phi, ximax + 1, dz)

            # perform integrals (avoiding singularity at xi)
            Ip = dz * np.sum(zp * np.exp(-zp**2) / (zp - xi[i]))
            Im = dz * np.sum(zm * np.exp(-zm**2) / (zm - xi[i]))

            # principal value:
            IPV[i] = Ip + Im

            # real pole contribution:
            RP[i] = 2 * phi * (1 - 2 * xi[i]**2)

        # now compute dW/dxi
        dW = (1 / np.sqrt(np.pi)) * (IPV + np.exp(-xi**2) * (RP - 1j * np.pi * xi))

        # generate and save table
        rdWT = np.column_stack((xi, -2 * np.real(dW)))
        idWT = np.column_stack((xi, 2 * np.imag(dW)))

        np.savetxt("Sheffield_zprime_rdWT.txt", rdWT, header="xi  -2*Re(dW/dxi)", comments="")
        np.savetxt("Sheffield_zprime_idWT.txt", idWT, header="xi   2*Im(dW/dxi)", comments="")
        print('finished')
    
    def _Zprime(self, xi, rdWT_file='Sheffield_zprime_rdWT.txt', idWT_file='Sheffield_zprime_idWT.txt'):
        """
        Compute the derivative of the plasma dispersion function.
        
        Parameters:
        -----------
        xi : ndarray
            Normalized phase velocity
        rdWT_file : str, optional
            File containing real part of dW/dxi (default: 'Sheffield_zprime_rdWT.txt')
        idWT_file : str, optional
            File containing imaginary part of dW/dxi (default: 'Sheffield_zprime_idWT.txt')
        
        Returns:
        --------
        ndarray
            Derivative of plasma dispersion function
        """
        # Generate tables if they don't exist
        if not os.path.exists(rdWT_file) or not os.path.exists(idWT_file):
            self._generate_dispersion_derivative_table()
        
        # Load table data
        rdWT = np.loadtxt(rdWT_file, skiprows=1)
        idWT = np.loadtxt(idWT_file, skiprows=1)

        xi = np.array(xi)
        xi_shape = xi.shape
        xi_flat = xi.flatten()

        rZp = np.zeros_like(xi_flat)
        iZp = np.zeros_like(xi_flat)

        # Interpolating functions
        interp_r = interp1d(rdWT[:, 0], rdWT[:, 1], kind='linear', bounds_error=False, fill_value="extrapolate")
        interp_i = interp1d(idWT[:, 0], idWT[:, 1], kind='linear', bounds_error=False, fill_value="extrapolate")

        # Apply interpolation and asymptotic approximation
        for idx, val in enumerate(xi_flat):
            if -10 <= val <= 10:
                rZp[idx] = interp_r(val)
                iZp[idx] = interp_i(val)
            else:
                rZp[idx] = 1 / val**2
                iZp[idx] = 0.0

        # Reshape to match input
        Zp = np.vstack((rZp.reshape(xi_shape), iZp.reshape(xi_shape)))
        return Zp
    
    def _compute_thomson_formfactor(self, omgs, omgL, Vpar=0, Vperp=0, ud=0, gamma=0, dphi=90):
        """
        Compute the Thomson scattering form factor.
        
        Parameters:
        -----------
        omgs : ndarray
            Angular frequencies for scattered light (rad/s)
        omgL : float
            Angular frequency of incident laser (rad/s)
        Vpar : float, optional
            Fluid velocity parallel to the Thomson laser in cm/s (default: 0)
        Vperp : float, optional
            Fluid velocity perpendicular to the Thomson laser in cm/s (default: 0)
        ud : float, optional
            Relative drift velocity between electrons and ions in cm/s (default: 0)
        gamma : float, optional
            Angle between k and the drift velocity in degrees (default: 0)
        dphi : float, optional
            Angle between plane of polarization and scattering plane in degrees (default: 90)
        
        Returns:
        --------
        ndarray
            Thomson scattering form factor S(k,w)
        """
        # Convert temperatures from eV to keV
        Te = self.T_e / 1000.0
        Ti = self.T_i / 1000.0
        
        # Constants
        C = 2.99792458e10                          # velocity of light cm/sec
        Me = 510.9896 / C**2                       # electron mass KeV/C^2
        Mp = Me * 1836.1                           # proton mass in same units
        Mi = self.A * Mp                           # ion mass in same units
        re = 2.8179e-13                            # classical electron radius cm
        Esq = Me * C**2 * re                       # sq of the electron charge KeV-cm
        wpe_norm = np.sqrt(4 * np.pi * Esq / Me)   # sqrt(4*pi*e^2/Me)

        sarad = np.radians(self.scattering_angle)
        dphirad = np.radians(dphi)
        gammarad = np.radians(gamma)

        omgpe = wpe_norm * np.sqrt(self.n_e)       # plasma frequency Rad/s
        omg = omgs - omgL
        ks = np.sqrt(omgs**2 - omgpe**2) / C
        kL = np.sqrt(omgL**2 - omgpe**2) / C       # laser wavenumber in Rad/cm
        k = np.sqrt(ks**2 + kL**2 - 2 * ks * kL * np.cos(sarad))
        kdotv = (kL - ks * np.cos(sarad)) * Vpar - ks * np.sin(sarad) * Vperp
        omgdop = omg - kdotv                       # doppler shifted frequencies omgs - omgL

        # Plasma parameters
        # Electrons
        vTe = np.sqrt(Te / Me)                     # electron thermal velocity
        klde = (vTe / omgpe) * k

        # Ions
        Zbar = np.sum(self.Z * self.fract)
        ni = self.fract * self.n_e / Zbar
        omgpi = wpe_norm * self.Z * np.sqrt(ni * Me / Mi)
        vTi = np.sqrt(Ti/Mi)                       # ion thermal velocity
        kldi = (vTi / omgpi).T * k

        # Electron susceptibility
        xd = ud / (np.sqrt(2) * vTe) * np.cos(gammarad)
        xie = omgdop / (k * np.sqrt(2) * vTe) - xd
        Zpe = self._Zprime(xie)
        chiE = -0.5 / (klde**2) * (Zpe[0, :] + 1j * Zpe[1, :])

        # Ion susceptibility
        xii = 1 / np.sqrt(2) * (omgdop / k)[None, :] / vTi[:, None]
        chiI = np.zeros_like(xii, dtype=complex)

        for m in range(len(self.Z)):
            Zpi = self._Zprime(xii[m])
            chiI[m] = -0.5 / (kldi[m]**2) * (Zpi[0, :] + 1j * Zpi[1, :])
        chiItot = np.sum(chiI, axis=0)

        econtr = (np.sqrt(2 * np.pi) / (vTe * k)) * np.exp(-xie**2) * np.abs((1 + chiItot) / (1 + chiItot + chiE))**2
        icontr = (2 * Ti / Te) * klde**2 / omgdop * (np.abs(chiE)**2 / np.abs(1 + chiItot + chiE)**2) * np.imag(chiItot)

        FF = econtr + icontr

        return (1 - np.sin(sarad)**2 * np.cos(dphirad)**2) * FF
    
    def compute_spectral_density(self, delta_lam=20, num_points=10000, update_params=True):
        """
        Compute the spectral density function S(k,w).
        
        Parameters:
        -----------
        delta_lam : float, optional
            Wavelength range to calculate around center wavelength in nm (default: 20)
        num_points : int, optional
            Number of points in wavelength array (default: 10000)
        update_params : bool, optional
            Whether to update stored parameters (default: True)
        
        Returns:
        --------
        tuple
            (alpha, omega_arr, omega_in, Skw)
        """
        # Define wavelength range and convert to frequency
        lambda_min = self.probe_wavelength - delta_lam
        lambda_max = self.probe_wavelength + delta_lam
        
        # Convert wavelength range to frequency range (note: inverse relationship)
        freq_max = self.c_speed / (lambda_min * 1e-9)
        freq_min = self.c_speed / (lambda_max * 1e-9)
        
        # Create frequency array
        freq_arr = np.linspace(freq_min, freq_max, num_points)
        omega_arr = 2 * np.pi * freq_arr  # rad/s
        
        # Compute spectral density
        Skw = self._compute_thomson_formfactor(omega_arr, self.omega_in)
        
        # Update stored parameters if requested
        if update_params:
            self.omega_arr = omega_arr
            self.Skw = Skw
        
        return self.alpha, omega_arr, self.omega_in, Skw
    
    def integrate_spectral_density(self):
        """
        Integrate the spectral density function over all frequencies.
        
        If spectral density hasn't been computed yet, compute it first.
        
        Returns:
        --------
        float
            Integrated spectral density
        """
        if self.omega_arr is None or self.Skw is None:
            _, self.omega_arr, _, self.Skw = self.compute_spectral_density()
        
        d_omega = np.mean(np.diff(self.omega_arr))
        return np.sum(self.Skw) * d_omega
    
    def update_parameters(self, **kwargs):
        """
        Update one or more parameters and recalculate dependent values.
        
        Parameters:
        -----------
        **kwargs : dict
            Parameters to update, can include:
            - probe_wavelength : float
                Probe wavelength in nm
            - T_e : float
                Electron temperature in eV
            - T_i : float
                Ion temperature in eV
            - n_e : float
                Electron density in cm^-3
            - scattering_angle : float
                Scattering angle in degrees
            - ions : str or tuple
                Ion species information
        
        Returns:
        --------
        SheffieldThomson
            Self (for method chaining)
        """
        # Update parameters
        update_needed = False
        for key, value in kwargs.items():
            if hasattr(self, key):
                setattr(self, key, value)
                update_needed = True
            elif key == 'ions':
                self._parse_ions(value)
                update_needed = True
        
        # Recalculate dependent parameters if needed
        if update_needed:
            if 'probe_wavelength' in kwargs:
                self.probe_freq = self.c_speed / (self.probe_wavelength * 1e-9)
                self.omega_in = 2 * np.pi * self.probe_freq
                self.lambda_i_cm = self.probe_wavelength * 1e-7
            
            # Recalculate alpha
            self.alpha = self.compute_alpha(self.lambda_i_cm, self.scattering_angle, self.n_e, self.T_e)
            
            # Invalidate cached results
            self.omega_arr = None
            self.Skw = None
        
        return self
    
    def power_ratio(self, L=0.1):
        """
        Calculate the ratio of scattered power to incident power.
        
        Parameters:
        -----------
        L : float, optional
            Length of the plasma in cm (default: 0.1)
        
        Returns:
        --------
        tuple
            (power_ratio, power_ratio_dB) where:
            - power_ratio is the linear power ratio (scattered/incident)
            - power_ratio_dB is the power ratio in decibels
        """
        # Calculate integration over all frequencies first
        integrated_Skw = self.integrate_spectral_density()
        
        # Calculate the power ratio
        scattering_angle_rad = np.radians(self.scattering_angle)
        result = r_0**2 * L / (4 * np.pi) * (1 + np.cos(scattering_angle_rad)**2) * self.n_e * integrated_Skw
        
        # Convert to dB
        result_dB = 10 * np.log10(result)
        
        return result, result_dB

# Functions to maintain backward compatibility with original code
def generate_dispersion_derivative_table(ximin=-10, ximax=10, dx=0.01, N=4):
    """Generate the derivative tables for the plasma dispersion function."""
    # Create a temporary calculator to use its method
    temp_calc = SheffieldThomson(532, 10, 1, 1e13)
    temp_calc._generate_dispersion_derivative_table(ximin, ximax, dx, N)

def Zprime(xi):
    """Compute derivative of the plasma dispersion function."""
    # Create a temporary calculator to use its method
    temp_calc = SheffieldThomson(532, 10, 1, 1e13)
    return temp_calc._Zprime(xi)

def compute_thomson_formfactor(omgs, omgL, Te=0.005, Ti=0.001, ne=1e13, Z=np.array([1]), 
                               A=np.array([4]), fract=np.array([1]), Vpar=0, Vperp=0, 
                               ud=0, gamma=0, sa=180, dphi=90):
    """
    Compute the Thomson scattering form factor using Sheffield's approach.
    
    This is maintained for backward compatibility with the original code.
    For new code, use the SheffieldThomson class instead.
    """
    # Create a calculator with the given parameters
    if isinstance(Ti, np.ndarray):
        Ti_val = Ti[0]
    else:
        Ti_val = Ti
    
    # Convert from keV to eV for the calculator
    calc = SheffieldThomson(
        probe_wavelength=300e9 * 299792458 * 1e9,  # Convert from Hz to nm
        T_e=Te * 1000,  # Convert from keV to eV
        T_i=Ti_val * 1000,  # Convert from keV to eV
        n_e=ne,
        scattering_angle=sa,
        ions=(Z, A, fract)
    )
    
    # Use the calculator to compute the form factor directly
    return calc._compute_thomson_formfactor(omgs, omgL, Vpar, Vperp, ud, gamma, dphi)

def integral_FF(omgs, omgL, Te=0.005, Ti=0.001, ne=1e13, Z=np.array([1]), 
                A=np.array([4]), fract=np.array([1]), Vpar=0, Vperp=0, 
                ud=0, gamma=0, sa=180, dphi=90):
    """
    Integrate the form factor over all frequencies.
    
    This is maintained for backward compatibility with the original code.
    """
    ff = compute_thomson_formfactor(
        omgs, omgL, Te=Te, Ti=Ti, ne=ne, Z=Z, A=A, fract=fract,
        Vpar=Vpar, Vperp=Vperp, ud=ud, gamma=gamma, sa=sa, dphi=dphi
    )
    d_omg = np.mean(np.diff(omgs))
    return np.sum(ff) * d_omg

# Simple container class for plasma parameters (maintained for compatibility)
class ntt:
    def __init__(self, ne, Te, Ti):
        self._ne = ne
        self._Te = Te
        self._Ti = Ti

    @property
    def ne(self):
        return self._ne

    @property
    def Te(self):
        return self._Te

    @property
    def Ti(self):
        return self._Ti

    @property
    def ntt(self):
        return self._ne, self._Te, self._Ti

# Example usage and testing
if __name__ == '__main__':
    # Original example
    F0 = 300e9
    delta_F = 20e9
    npts = 50000
    omgs = np.linspace(F0-delta_F, F0+delta_F, npts) * 2*np.pi
    omgL = F0 * 2*np.pi

    parms = [
        ntt(1e12, 10, 3),
        ntt(5e12, 7, 4),
        ntt(2e13, 3, 1)
    ]

    plt.figure(figsize=(10, 6))
    plt.xlabel('Scattered Frequency Fs [GHz]')
    plt.ylabel('Thomson Form Factor')
    plt.title('Thomson Scattering Form Factor $S(k, \omega)$ vs Scattered Frequency')
    plt.grid(True)
    plt.tight_layout()
    plt.xlim(0, 2)

    # Compare original function with class-based approach
    for i in range(len(parms)):
        ne, Te, Ti = parms[i].ntt
        
        # Using original function
        Skw_orig = compute_thomson_formfactor(
            omgs, omgL,
            Te=Te/1000,
            Ti=Ti/1000,
            ne=ne,
            Z=np.array([1]),
            A=np.array([1]),
            fract=np.array([1]),
            Vpar=0, Vperp=0, ud=0,
            gamma=0,
            sa=180,
            dphi=90
        )
        
        # Using new class
        calc = SheffieldThomson(
            probe_wavelength=299792458/(F0*1e-9),  # convert Hz to nm
            T_e=Te,
            T_i=Ti,
            n_e=ne,
            scattering_angle=180,
            ions="H+"  # Use H+ to match original A=1
        )
        _, _, _, Skw_class = calc.compute_spectral_density(num_points=npts)
        
        label = f"ne={(ne/1e13):.1f}, Te={Te:.1f}, Ti={Ti:.1f}"
        plt.plot(omgs/(2*np.pi*1e9) - F0/1e9, Skw_orig, label=label + " (orig)")
        plt.plot(omgs/(2*np.pi*1e9) - F0/1e9, Skw_class, '--', label=label + " (class)")
        
        # Calculate and print power ratio
        Stot = np.sum(Skw_orig) * np.mean(np.diff(omgs))
        print(label, '   integrated Stot = %.2f' % Stot)
        
        # Scattering fraction calculation
        re0 = 2.818e-15  # m
        C = 2.99792458e8  # velocity of light m/sec
        lambda0 = C / F0  # m
        Ncycles = 32
        L = Ncycles * lambda0  # m
        ne_m3 = ne * 1e6  # convert to m^-3
        fract_power = 2*re0**2*L*ne_m3*Stot
        
        print('  Ps/Pi=%e into 4pi sr, for L = N*lambda = %.1f cm' % (fract_power, L*100))

    plt.legend()
    plt.show()

def Sheffield_Behn_example():
    """Reproduce the Sheffield_Behn example from the original code."""
    # Frequency range
    F0 = 3e8/385e-6
    omgs = np.linspace(F0-2e9, F0+2e9, 5000) * 2*np.pi
    omgL = F0 * 2*np.pi

    # these numbers roughly match Figure from [Behn, 1989]
    neg = 5e13
    Te = 300
    Ti_vals = np.array([100, 200, 300, 400], dtype='float64')

    plt.figure(figsize=(10, 6))
    plt.xlabel('Scattered Frequency Fs [GHz]')
    plt.ylabel('Thomson Form Factor')
    plt.title('Thomson Scattering Form Factor $S(k, \omega)$ vs Scattered Frequency')
    plt.grid(True)
    plt.tight_layout()
    plt.xlim(0, 1.4)

    for i, Ti in enumerate(Ti_vals):
        # Create a SheffieldThomson calculator
        calc = SheffieldThomson(
            probe_wavelength=299792458/(F0*1e-9),  # convert Hz to nm
            T_e=Te,
            T_i=Ti,
            n_e=neg,
            scattering_angle=90,
            ions=(np.array([4]), np.array([4]), np.array([1]))  # He++
        )
        
        # Calculate spectral density
        _, omega_arr, _, Skw = calc.compute_spectral_density(num_points=5000)
        
        label = f"ne={(neg/1e13):.1f}, Te={Te}, Ti={Ti}"
        if i == 0:
            plt.plot(omega_arr/(2*np.pi*1e9) - F0/1e9, Skw/3, label=label + ' { ÷ 3}')
        else:
            plt.plot(omega_arr/(2*np.pi*1e9) - F0/1e9, Skw, label=label)

    plt.legend()
    plt.show()
